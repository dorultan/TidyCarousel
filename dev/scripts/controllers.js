import Actions from './actions';

// TODO:
//  - Handle another case in the onArrowClick wich should determine when
//	  the current and next should swap.
// 	  This should solve the case where the numbers are not increasing when the
// 		auto is true
//
//  - Add an extra callback to the mecanism wich is should be executed only if
// 		the reset option is true.
//  - Make a hook to check if the slides are generated by actions.generateSlides()
// 		if so, change selectors, could be something like parent.children(n).
//  - Trigger the onSwipeEnd function when the mouseleave event occurs.
//  - Do a check how a generated controller would look like.
//  - Write tests. Make sure every method is clean, and the tree is shaked.
//  - Get ready the controllers to be depolyable, enjoy.
//  - Make a clear distinction between pause and mouseenter, swipe/drag can't initialize if onMouseEnter pause is set to true. Make a clear reference when the pause should be set to true.
// ==================================================================
class Controllers extends Actions {
	constructor(props) {
		super(props);
		this.pause = false;
		this.current_slide = this.startAt;
		this.next_slide = this.startAt;
		this.delay_timer = 0;
		this.duration_timer = 0;
		this.direction = null;
		this.dragable = false;
		this.start_x = 0;
		this.end_x = 0;
		this.current_continue_from = 0;
		this.next_continue_from = 0;
		this.swipe_stopped = false;
		this.mouseenter = false;

		if(Array.isArray(this.slides)) {
			this.generateSlides();
		}

		if(this.pager) {
			this.generatePager();
			this.pages.forEach(btn => {
				btn.addEventListener('click', this.onPagerClick.bind(this));
			})
		}
		this.setActiveSlide();

		if(this.auto) {
			let trigger = this.delayTimer();
		}

		if(this.controllers) {
			this.controllers.forEach(btn => {
				btn.addEventListener('click', this.shouldPause.bind(this));
			})
		}

		this.container.addEventListener('mouseenter',this.onMouseEnter.bind(this));
		this.container.addEventListener('mouseleave',this.onMouseLeave.bind(this));

		if(this.drag) {
			this.container.addEventListener('mousedown', this.onSwipe.bind(this));
			this.container.addEventListener('mousemove', this.onSwipeStart.bind(this), {passive: true});
			this.container.addEventListener('mouseup', this.onSwipeEnd.bind(this));
		}

		if(this.swipe) {
			this.container.addEventListener('touchstart', this.onSwipe.bind(this), {passive: true});
			this.container.addEventListener('touchmove', this.onSwipeStart.bind(this), {passive: true});
			this.container.addEventListener('touchend', this.onSwipeEnd.bind(this));
		}

	}

	onSwipe(e) {
		this.mouseenter = true;

		clearTimeout(this.delay_timer);
		clearTimeout(this.duration_timer);

		if(this.pause || this.dragable) {
			return false;
		}
		// if(shouldStop) {
		// 	return false;
		// }

		if(this.start_x - this.end_x !== 0 && this.swipe_stopped) {
			return false;
		}
		this.start_x = e.clientX || e.changedTouches[0].clientX;
		this.dragable = true;
		this.current_slide = this.current_slide === null ? 0 : this.next_slide !== null ? this.next_slide : this.current_slide;

	}

	onSwipeStart(e) {
		const total_slides = this.container.children.length -1;
		this.mouseenter = true;
		// if(e.type === 'mousemove' && !e.target.classList.contains('tidyCarousel-slide')) {
		// 	return false
		// }
		if(this.swipe_stopped) {
			return false;
		}
		// Get to know in wich direction is swiping
		// get to know what's the total pixels of the swipe.
		let total = e.target.clientWidth || e.view.clientWidth;
		let half = total / 2;
		this.shouldInfinite(false)
		if(this.dragable) {
			this.end_x = e.pageX || e.changedTouches[0].clientX;
			this.direction = this.start_x - this.end_x > 0 ? 'left' : 'right';
			const shouldStop = this.shouldInfinite(false);


			if(!shouldStop) {

				this.current_continue_from = (this.end_x - this.start_x) * 100 / total;
				this.next_continue_from = (this.start_x - this.end_x) * 100 / total;
				if(this.direction === 'left') {
					this.next_slide = this.current_slide -1 < 0 ? total_slides : this.current_slide -1;
				}

				if(this.direction === 'right') {
					this.next_slide = this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
				}

				// this.end_x = 0;
				// this.start_x = 0;
				// // distance = 0;
			// this.current_continue_from = 0;
			// this.next_continue_from = 0;
				this.swipeAnimation(this.current_continue_from, this.next_continue_from);
			}
		}
	}

	onSwipeEnd(e) {

		const total_slides = this.container.children.length -1;
		this.dragable = false;
		this.mouseenter = false;

		if(this.current_slide === this.next_slide) {
			return false;
		}

		if(this.swipe_stopped || this.end_x === 0) {
			return false;
		}
		// this.pause = false;
		else if(((this.start_x - this.end_x > 100) || (this.start_x - this.end_x < -100)) && !this.swipe_stopped) {

			this.beforeAnimationStarts();
			this.doAnimation(null, this.current_continue_from, this.next_continue_from, false)

			.then(() => {
				this.afterAnimationEnds();
				this.end_x = 0;
				this.start_x = 0;
				if(this.direction === 'left') {
					this.current_slide = this.current_slide -1 === -1 ? total_slides : this.current_slide -1;
				}

				if(this.direction === 'right') {
					this.current_slide = this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
				}

				for(let item of this.container.children) {

					if(item.hasAttribute('style')) {
						item.removeAttribute('style');
					}
				}
			})
		}
		else {
				this.next_slide = this.current_slide;
				this.end_x = 0;
				this.start_x = 0;
			for(let item of this.container.children) {
				if(item.hasAttribute('style')) {
					this.doAnimation(null, this.current_continue_from, this.next_continue_from, true)
					.then(() => {
						this.end_x = 0;
						this.start_x = 0;
						item.removeAttribute('style');
						this.pause = false;
						this.shouldRestart();
					})
				}
			}
		}
		this.mouseenter = false;
	}

	beforeAnimationStarts() {
		this.pause = true;
		if(this.pager) {
			this.setActivePage();
		}
		if(Array.isArray(this.slides)) {
			if(this.slides[this.next_slide].beforeAnimation) {
				this.slides[this.next_slide].beforeAnimation(this.container.children[this.next_slide], this.next_slide).bind(this);
			}
		}

		if(this.opts.beforeAnimation) {
			this.opts.beforeAnimation(this.container.children[this.next_slide], this.next_slide).bind(this)
		}


	}

	shouldInfinite(auto, arrows) {

		if(!this.infinite) {

			if(auto) {
				if(this.autoDirection === 'right') {
						const shouldStop =	this.next_slide === this.container.children.length -1 ? true : false;
						return shouldStop;
				}
				else if(this.autoDirection === 'left') {
						const shouldStop = this.next_slide === 0 ? true : false;
						return shouldStop;
				}
			}

			else if(arrows) {
				if(this.direction === 'right') {
						const shouldStop =	this.next_slide === this.container.children.length -1 ? true : false;
						return shouldStop;
				}
				else if(this.direction === 'left') {
						const shouldStop = this.next_slide === 0 ? true : false;
						return shouldStop;
				}
			}
			else if(!auto && !arrows) {
				if(this.direction === 'right') {
						const shouldStop =	this.current_slide === this.container.children.length -1 ? true : false;
						return shouldStop;
				}
				else if(this.direction === 'left') {
						const shouldStop = this.current_slide === 0 ? true : false;
						return shouldStop;
				}
			}

			return false;
		}

		// if(!this.infinite) {
		// 	let shouldStop;
		// 	if(this.autoDirection === 'right') {
		// 		shouldStop = this.current_slide === this.container.children.length - 1 ? true : false;
		//
		// 		return shouldStop;
		// 	}
		// 	if(this.autoDirection === 'left') {
		// 		shouldStop = this.current_slide === 0 ? true : false;
		//
		// 		return shouldStop;
		// 	}
		// }
	}

	shouldRestart() {
		if(this.mouseenter) {
			return false;
		}

		if(this.auto) {

			this.delayTimer();
		}
	}
	// @param timer: boolean
	afterAnimationEnds(timer) {
		this.swipe_stopped = false;
		this.pause = true;

		if(this.auto) {

				if(Array.isArray(this.slides)) {

						if(typeof this.slides[this.next_slide].afterAnimation === 'function') {
							this.slides[this.next_slide].afterAnimation(this.container.children[this.next_slide], this.next_slide)

							.then(() => {
								this.pause = false;

									this.shouldRestart();
							})
						}
						else {
							this.pause = false;
								this.shouldRestart();
						}
				}

				else {
					if(this.opts.afterAnimation) {

							this.opts.afterAnimation(this.container.children[this.next_slide], this.next_slide)

							.then((data) => {
								this.pause = false;
								this.shouldRestart();
							})
					}
					else {
							this.pause = false;
							this.shouldRestart();
					}
				}
		}
		else {
			this.pause = false;
		}

	}

	onMouseEnter() {
		if(this.pauseOnMouseEnter) {
			if(this.auto) {
				clearTimeout(this.delay_timer);
				this.mouseenter = true;
			}
		}

		return false;
	}

	onMouseLeave(e) {
		this.onSwipeEnd(e);
		let time;
		// Clearing the delay_timer will restart the delay.
		// ================================================

		if(this.auto) {
			clearTimeout(this.duration_timer);
			clearTimeout(this.delay_timer);
			this.mouseenter = false;

			// const shouldStop = this.shouldInfinite(true);
			this.delayTimer();
		}
	}

	delayTimer(e) {
		const shouldStop = this.shouldInfinite(true);
		if(shouldStop) {
			return false;
		}
		if(!this.pause) {
			this.delay_timer = setTimeout(() => {

				if(this.autoDirection && !this.mouseenter) {
					this.durationTimer();
				}
			},this.delay);
		}
	}

	durationTimer() {
		const shouldReset = this.shouldReset(this.autoDirection);
		if(this.mouseenter) {
			return false;
		}
		if(!this.pause) {
			this.duration_timer = setTimeout(() => {
				this.delayTimer();
				clearTimeout(this.delay_timer);

				if(!this.infinite && shouldReset) {
					return clearTimeout(this.delay_timer);
				}

				if(!this.mouseenter) {
					this.autoControl();
				}

			}, this.duration)
		}
	}

	getDirection(e) {
		const button = e.path.filter((e) => {
			if(e.attributes) {
				 return e.hasAttribute('data-carousel-controller');
			}
		});

		return button[0].attributes.getNamedItem('data-carousel-controller').value;
	}

	shouldPause(e) {
		const listener_name = this.getDirection(e);
		const shouldReset = this.shouldReset(listener_name);

		if(this.pause) {
			return false;
		}

		if(shouldReset) {
			return false;
		}

		this.onArrowClick(e);
	}

	shouldReset(dir) {
		let total_slides = this.container !== null ? this.container.length - 1 : false;

		if(!total_slides) {return false};

		if(dir === 'left') {
			if(this.next_slide - 1 === -1) {
				return true;
			}
		}

		if(dir === 'right') {
			if(this.next_slide + 1 > total_slides) {
				return true;
			}
		}

		return false;
	}

	onArrowClick(e) {
		const listener_name = this.getDirection(e);
		const total_slides = this.container.children.length -1;

		const shouldSwap = this.direction === null ? false : listener_name !== this.direction ;
		const shouldStop = this.shouldInfinite(false, true);

		if(shouldStop && !shouldSwap) {
			return false;
		}

		this.mouseenter = false;

		if(shouldSwap && this.next_slide !== this.current_slide) {

			this.next_slide ^= this.current_slide;
			this.current_slide ^= this.next_slide;
			this.next_slide ^= this.current_slide;

			if(this.next_slide === this.current_slide) {
				this.next_slide = listener_name === 'left' ? this.current_slide - 1 : this.current_slide + 1;
			}

			this.direction = listener_name;
		}

		if(shouldSwap && this.next_slide === this.current_slide) {
			if(listener_name === 'left' && this.current_slide !== null && this.next_slide !== null) {
				this.next_slide = this.current_slide - 1 === -1 ? total_slides : this.current_slide - 1;
			}

			if(listener_name === 'right' && this.current_slide !== null && this.next_slide !== null) {
				this.next_slide = this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
			}
			this.direction = listener_name;
		}

		if(listener_name === 'left' && !shouldSwap) {

			if(this.current_slide && this.next_slide === null) {
				this.next_slide = this.current_slide - 1 === -1 ? total_slides : this.current_slide - 1;
			}

			else if(this.next_slide === this.current_slide && this.current_slide !== null && this.next_slide !== null) {
				this.next_slide = this.current_slide - 1 === -1 ? total_slides : this.current_slide - 1;
			}

			else {
				this.current_slide = this.current_slide === null ? 0 : (this.current_slide - 1) === -1 ? total_slides : this.current_slide -1;
				this.next_slide = this.next_slide === null ? total_slides : this.current_slide === 0 ? total_slides : this.current_slide -1;
			}

			this.direction = listener_name;

		}

		if(listener_name === 'right' && !shouldSwap) {
			if(this.current_slide && this.next_slide === null) {
				this.next_slide = this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
			}

			else if(this.next_slide === this.current_slide && this.current_slide !== null && this.next_slide !== null) {

				this.next_slide = this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
			}
			else {
				this.current_slide = this.current_slide === null ? 0 : this.current_slide + 1 > (total_slides) ? 0 : this.current_slide + 1;
				this.next_slide = this.next_slide === null ? 1 : this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
			}

			this.direction = listener_name;
		}
		this.beforeAnimationStarts();
		this.doAnimation()

		.then(() => {
			this.afterAnimationEnds();
		});
	}

	onPagerClick(e) {
		e.preventDefault();
		let _next_slide;
		let direction;
		if(this.pause) {
			return false;
		}

		if(e.target.id) {

			_next_slide = parseInt(e.target.id);
			this.current_slide = this.current_slide === null ? 0 : this.next_slide;
			this.next_slide = _next_slide;
			direction = _next_slide < this.current_slide ? 'left' : 'right';
			this.direction = direction;

			if(this.current_slide === this.next_slide) {
				return false;
			}

			this.beforeAnimationStarts();
			this.doAnimation()

			.then(this.afterAnimationEnds.bind(this));
			this.current_slide = _next_slide;

		}
	}

	// autoControl: Is the controller responsibile for handling the auto animations.
	// ==============================================================================

	autoControl() {
		const shouldSwap = this.direction === null ? false : this.autoDirection !== this.direction;
		const total_slides = this.container !== null ? this.container.children.length -1 : false;

		if(!total_slides) {
			clearTimeout(this.delay_timer);
			return false;
		}

		if(this.pause) {
			return false;
		}

		if(!this.autoDirection) {

			return false;
		}

		if(shouldSwap) {
			this.next_slide ^= this.current_slide;
			this.current_slide ^= this.next_slide;
			this.next_slide ^= this.current_slide;

			if(this.next_slide === this.current_slide) {

				if(this.autoDirection === 'left') {
					this.next_slide = this.current_slide -1 === -1 ? total_slides : this.current_slide - 1;
				}

				if(this.autoDirection === 'right') {
					this.next_slide = this.current_slide + 1 > total_slides + 1 ? 0 : this.current_slide + 1;
				}
			}
		}


		if(this.autoDirection === 'left' && !shouldSwap) {
			if(this.current_slide && this.next_slide === null) {
					this.next_slide = this.current_slide - 1 === -1 ? total_slides : this.current_slide - 1;
			}

			else if(this.next_slide === this.current_slide && this.current_slide !== null && this.next_slide !== null) {
					this.next_slide = this.current_slide - 1 === -1 ? total_slides : this.current_slide - 1;
				}

			else {
				this.current_slide = this.current_slide === null ? 0 : (this.current_slide - 1) === -1 ? total_slides : this.current_slide -1;
				this.next_slide = this.next_slide === null ? total_slides : this.current_slide === 0 ? total_slides : this.current_slide -1;
			}
		}

		else if(this.autoDirection === 'right' && !shouldSwap) {

			if(this.current_slide && this.next_slide === null) {
				this.next_slide = this.current_slide + 1 === total_slides + 1 ? 0 : this.current_slide + 1;
			}

			else if(this.next_slide === this.current_slide && this.current_slide !== null && this.next_slide !== null) {
				this.next_slide = this.current_slide + 1 === total_slides + 1 ? 0 : this.current_slide + 1;
			}
			else {
				this.current_slide = this.current_slide === null ? 0 : this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
				this.next_slide = this.next_slide === null ? 1 : this.current_slide + 1 > total_slides ? 0 : this.current_slide + 1;
			}
		}
		this.direction = this.autoDirection;
		this.beforeAnimationStarts();
		this.doAnimation(this.autoDirection)

		.then(this.afterAnimationEnds.bind(this));
	}
}

export default Controllers;
